/*
 * The Span API
 *
 * API for device, collection, output and firmware management
 *
 * The version of the OpenAPI document: 5.0.1 humorous-jaron
 * Contact: dev@lab5e.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using Com.Lab5e.Span.Client;
using Com.Lab5e.Span.Model;

namespace Com.Lab5e.Span.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ICertificatesApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Create certificate
        /// </summary>
        /// <remarks>
        /// Create a new device or gateway (client) certificate for an internet-connected device. The devices will use this client certificate to authenticate when sending data via the Internet endpoint. This will create a X509 client certificate with an ECC public key. The key is not stored by the service so keep it in a secure place once it is downloaded. The returned certificate will be valid for 14 days. The key for the certificate is your own responsibility. The client certificate is used in both the TLS, DTLS and gRPC service endpoints.
        /// </remarks>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CreateCertificateResponse</returns>
        CreateCertificateResponse CreateCertificate(string collectionId, CreateCertificateBody body, int operationIndex = 0);

        /// <summary>
        /// Create certificate
        /// </summary>
        /// <remarks>
        /// Create a new device or gateway (client) certificate for an internet-connected device. The devices will use this client certificate to authenticate when sending data via the Internet endpoint. This will create a X509 client certificate with an ECC public key. The key is not stored by the service so keep it in a secure place once it is downloaded. The returned certificate will be valid for 14 days. The key for the certificate is your own responsibility. The client certificate is used in both the TLS, DTLS and gRPC service endpoints.
        /// </remarks>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CreateCertificateResponse</returns>
        ApiResponse<CreateCertificateResponse> CreateCertificateWithHttpInfo(string collectionId, CreateCertificateBody body, int operationIndex = 0);
        /// <summary>
        /// Get certificate chain
        /// </summary>
        /// <remarks>
        /// Get the certificate chain for the root CA and intermediate certificates used by the device, gateway and server certificates. It is highly recommended to verify the server certificate when sending data to avoid any man-in-the-middle attacks. This chain will contain all required certificates needed to verify the client certificate.
        /// </remarks>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="deviceId"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CertificateChainResponse</returns>
        CertificateChainResponse RetrieveCertificateChain(string collectionId, string? gatewayId = default(string?), string? deviceId = default(string?), int operationIndex = 0);

        /// <summary>
        /// Get certificate chain
        /// </summary>
        /// <remarks>
        /// Get the certificate chain for the root CA and intermediate certificates used by the device, gateway and server certificates. It is highly recommended to verify the server certificate when sending data to avoid any man-in-the-middle attacks. This chain will contain all required certificates needed to verify the client certificate.
        /// </remarks>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="deviceId"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CertificateChainResponse</returns>
        ApiResponse<CertificateChainResponse> RetrieveCertificateChainWithHttpInfo(string collectionId, string? gatewayId = default(string?), string? deviceId = default(string?), int operationIndex = 0);
        /// <summary>
        /// Sign certificate
        /// </summary>
        /// <remarks>
        /// Sign a device or gateway (aka client) certificate. The certificate is a X509 Certificate signing request PEM encoded. The certificate will be valid for 14 days and must be renewed.
        /// </remarks>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignCertificateResponse</returns>
        SignCertificateResponse SignCertificate(string collectionId, SignCertificateBody body, int operationIndex = 0);

        /// <summary>
        /// Sign certificate
        /// </summary>
        /// <remarks>
        /// Sign a device or gateway (aka client) certificate. The certificate is a X509 Certificate signing request PEM encoded. The certificate will be valid for 14 days and must be renewed.
        /// </remarks>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignCertificateResponse</returns>
        ApiResponse<SignCertificateResponse> SignCertificateWithHttpInfo(string collectionId, SignCertificateBody body, int operationIndex = 0);
        /// <summary>
        /// Verify certificate
        /// </summary>
        /// <remarks>
        /// Verify client certificate. If a client certificate fails it can be tricky to pinpoint exactly *why* the certificate isn&#39;t accepted. This resource validates the client certificate and returns the error in plain text.
        /// </remarks>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>VerifyCertificateResponse</returns>
        VerifyCertificateResponse VerifyCertificate(string collectionId, VerifyCertificateBody body, int operationIndex = 0);

        /// <summary>
        /// Verify certificate
        /// </summary>
        /// <remarks>
        /// Verify client certificate. If a client certificate fails it can be tricky to pinpoint exactly *why* the certificate isn&#39;t accepted. This resource validates the client certificate and returns the error in plain text.
        /// </remarks>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of VerifyCertificateResponse</returns>
        ApiResponse<VerifyCertificateResponse> VerifyCertificateWithHttpInfo(string collectionId, VerifyCertificateBody body, int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ICertificatesApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Create certificate
        /// </summary>
        /// <remarks>
        /// Create a new device or gateway (client) certificate for an internet-connected device. The devices will use this client certificate to authenticate when sending data via the Internet endpoint. This will create a X509 client certificate with an ECC public key. The key is not stored by the service so keep it in a secure place once it is downloaded. The returned certificate will be valid for 14 days. The key for the certificate is your own responsibility. The client certificate is used in both the TLS, DTLS and gRPC service endpoints.
        /// </remarks>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CreateCertificateResponse</returns>
        System.Threading.Tasks.Task<CreateCertificateResponse> CreateCertificateAsync(string collectionId, CreateCertificateBody body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create certificate
        /// </summary>
        /// <remarks>
        /// Create a new device or gateway (client) certificate for an internet-connected device. The devices will use this client certificate to authenticate when sending data via the Internet endpoint. This will create a X509 client certificate with an ECC public key. The key is not stored by the service so keep it in a secure place once it is downloaded. The returned certificate will be valid for 14 days. The key for the certificate is your own responsibility. The client certificate is used in both the TLS, DTLS and gRPC service endpoints.
        /// </remarks>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CreateCertificateResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<CreateCertificateResponse>> CreateCertificateWithHttpInfoAsync(string collectionId, CreateCertificateBody body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get certificate chain
        /// </summary>
        /// <remarks>
        /// Get the certificate chain for the root CA and intermediate certificates used by the device, gateway and server certificates. It is highly recommended to verify the server certificate when sending data to avoid any man-in-the-middle attacks. This chain will contain all required certificates needed to verify the client certificate.
        /// </remarks>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="deviceId"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CertificateChainResponse</returns>
        System.Threading.Tasks.Task<CertificateChainResponse> RetrieveCertificateChainAsync(string collectionId, string? gatewayId = default(string?), string? deviceId = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get certificate chain
        /// </summary>
        /// <remarks>
        /// Get the certificate chain for the root CA and intermediate certificates used by the device, gateway and server certificates. It is highly recommended to verify the server certificate when sending data to avoid any man-in-the-middle attacks. This chain will contain all required certificates needed to verify the client certificate.
        /// </remarks>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="deviceId"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CertificateChainResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<CertificateChainResponse>> RetrieveCertificateChainWithHttpInfoAsync(string collectionId, string? gatewayId = default(string?), string? deviceId = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Sign certificate
        /// </summary>
        /// <remarks>
        /// Sign a device or gateway (aka client) certificate. The certificate is a X509 Certificate signing request PEM encoded. The certificate will be valid for 14 days and must be renewed.
        /// </remarks>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignCertificateResponse</returns>
        System.Threading.Tasks.Task<SignCertificateResponse> SignCertificateAsync(string collectionId, SignCertificateBody body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Sign certificate
        /// </summary>
        /// <remarks>
        /// Sign a device or gateway (aka client) certificate. The certificate is a X509 Certificate signing request PEM encoded. The certificate will be valid for 14 days and must be renewed.
        /// </remarks>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignCertificateResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignCertificateResponse>> SignCertificateWithHttpInfoAsync(string collectionId, SignCertificateBody body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Verify certificate
        /// </summary>
        /// <remarks>
        /// Verify client certificate. If a client certificate fails it can be tricky to pinpoint exactly *why* the certificate isn&#39;t accepted. This resource validates the client certificate and returns the error in plain text.
        /// </remarks>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VerifyCertificateResponse</returns>
        System.Threading.Tasks.Task<VerifyCertificateResponse> VerifyCertificateAsync(string collectionId, VerifyCertificateBody body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Verify certificate
        /// </summary>
        /// <remarks>
        /// Verify client certificate. If a client certificate fails it can be tricky to pinpoint exactly *why* the certificate isn&#39;t accepted. This resource validates the client certificate and returns the error in plain text.
        /// </remarks>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (VerifyCertificateResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<VerifyCertificateResponse>> VerifyCertificateWithHttpInfoAsync(string collectionId, VerifyCertificateBody body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ICertificatesApi : ICertificatesApiSync, ICertificatesApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class CertificatesApi : ICertificatesApi
    {
        private Com.Lab5e.Span.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="CertificatesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public CertificatesApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CertificatesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public CertificatesApi(string basePath)
        {
            this.Configuration = Com.Lab5e.Span.Client.Configuration.MergeConfigurations(
                Com.Lab5e.Span.Client.GlobalConfiguration.Instance,
                new Com.Lab5e.Span.Client.Configuration { BasePath = basePath }
            );
            this.Client = new Com.Lab5e.Span.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Com.Lab5e.Span.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Com.Lab5e.Span.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CertificatesApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public CertificatesApi(Com.Lab5e.Span.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Com.Lab5e.Span.Client.Configuration.MergeConfigurations(
                Com.Lab5e.Span.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new Com.Lab5e.Span.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Com.Lab5e.Span.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Com.Lab5e.Span.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CertificatesApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public CertificatesApi(Com.Lab5e.Span.Client.ISynchronousClient client, Com.Lab5e.Span.Client.IAsynchronousClient asyncClient, Com.Lab5e.Span.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Com.Lab5e.Span.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Com.Lab5e.Span.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Com.Lab5e.Span.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Com.Lab5e.Span.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Com.Lab5e.Span.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Create certificate Create a new device or gateway (client) certificate for an internet-connected device. The devices will use this client certificate to authenticate when sending data via the Internet endpoint. This will create a X509 client certificate with an ECC public key. The key is not stored by the service so keep it in a secure place once it is downloaded. The returned certificate will be valid for 14 days. The key for the certificate is your own responsibility. The client certificate is used in both the TLS, DTLS and gRPC service endpoints.
        /// </summary>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CreateCertificateResponse</returns>
        public CreateCertificateResponse CreateCertificate(string collectionId, CreateCertificateBody body, int operationIndex = 0)
        {
            Com.Lab5e.Span.Client.ApiResponse<CreateCertificateResponse> localVarResponse = CreateCertificateWithHttpInfo(collectionId, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create certificate Create a new device or gateway (client) certificate for an internet-connected device. The devices will use this client certificate to authenticate when sending data via the Internet endpoint. This will create a X509 client certificate with an ECC public key. The key is not stored by the service so keep it in a secure place once it is downloaded. The returned certificate will be valid for 14 days. The key for the certificate is your own responsibility. The client certificate is used in both the TLS, DTLS and gRPC service endpoints.
        /// </summary>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CreateCertificateResponse</returns>
        public Com.Lab5e.Span.Client.ApiResponse<CreateCertificateResponse> CreateCertificateWithHttpInfo(string collectionId, CreateCertificateBody body, int operationIndex = 0)
        {
            // verify the required parameter 'collectionId' is set
            if (collectionId == null)
            {
                throw new Com.Lab5e.Span.Client.ApiException(400, "Missing required parameter 'collectionId' when calling CertificatesApi->CreateCertificate");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Com.Lab5e.Span.Client.ApiException(400, "Missing required parameter 'body' when calling CertificatesApi->CreateCertificate");
            }

            Com.Lab5e.Span.Client.RequestOptions localVarRequestOptions = new Com.Lab5e.Span.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Com.Lab5e.Span.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Com.Lab5e.Span.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("collectionId", Com.Lab5e.Span.Client.ClientUtils.ParameterToString(collectionId)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "CertificatesApi.CreateCertificate";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (APIToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-Token", this.Configuration.GetApiKeyWithPrefix("X-API-Token"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<CreateCertificateResponse>("/span/collections/{collectionId}/certificates/create", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateCertificate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create certificate Create a new device or gateway (client) certificate for an internet-connected device. The devices will use this client certificate to authenticate when sending data via the Internet endpoint. This will create a X509 client certificate with an ECC public key. The key is not stored by the service so keep it in a secure place once it is downloaded. The returned certificate will be valid for 14 days. The key for the certificate is your own responsibility. The client certificate is used in both the TLS, DTLS and gRPC service endpoints.
        /// </summary>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CreateCertificateResponse</returns>
        public async System.Threading.Tasks.Task<CreateCertificateResponse> CreateCertificateAsync(string collectionId, CreateCertificateBody body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Com.Lab5e.Span.Client.ApiResponse<CreateCertificateResponse> localVarResponse = await CreateCertificateWithHttpInfoAsync(collectionId, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create certificate Create a new device or gateway (client) certificate for an internet-connected device. The devices will use this client certificate to authenticate when sending data via the Internet endpoint. This will create a X509 client certificate with an ECC public key. The key is not stored by the service so keep it in a secure place once it is downloaded. The returned certificate will be valid for 14 days. The key for the certificate is your own responsibility. The client certificate is used in both the TLS, DTLS and gRPC service endpoints.
        /// </summary>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CreateCertificateResponse)</returns>
        public async System.Threading.Tasks.Task<Com.Lab5e.Span.Client.ApiResponse<CreateCertificateResponse>> CreateCertificateWithHttpInfoAsync(string collectionId, CreateCertificateBody body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'collectionId' is set
            if (collectionId == null)
            {
                throw new Com.Lab5e.Span.Client.ApiException(400, "Missing required parameter 'collectionId' when calling CertificatesApi->CreateCertificate");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Com.Lab5e.Span.Client.ApiException(400, "Missing required parameter 'body' when calling CertificatesApi->CreateCertificate");
            }


            Com.Lab5e.Span.Client.RequestOptions localVarRequestOptions = new Com.Lab5e.Span.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Com.Lab5e.Span.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Com.Lab5e.Span.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("collectionId", Com.Lab5e.Span.Client.ClientUtils.ParameterToString(collectionId)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "CertificatesApi.CreateCertificate";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (APIToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-Token", this.Configuration.GetApiKeyWithPrefix("X-API-Token"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<CreateCertificateResponse>("/span/collections/{collectionId}/certificates/create", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateCertificate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get certificate chain Get the certificate chain for the root CA and intermediate certificates used by the device, gateway and server certificates. It is highly recommended to verify the server certificate when sending data to avoid any man-in-the-middle attacks. This chain will contain all required certificates needed to verify the client certificate.
        /// </summary>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="deviceId"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CertificateChainResponse</returns>
        public CertificateChainResponse RetrieveCertificateChain(string collectionId, string? gatewayId = default(string?), string? deviceId = default(string?), int operationIndex = 0)
        {
            Com.Lab5e.Span.Client.ApiResponse<CertificateChainResponse> localVarResponse = RetrieveCertificateChainWithHttpInfo(collectionId, gatewayId, deviceId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get certificate chain Get the certificate chain for the root CA and intermediate certificates used by the device, gateway and server certificates. It is highly recommended to verify the server certificate when sending data to avoid any man-in-the-middle attacks. This chain will contain all required certificates needed to verify the client certificate.
        /// </summary>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="deviceId"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CertificateChainResponse</returns>
        public Com.Lab5e.Span.Client.ApiResponse<CertificateChainResponse> RetrieveCertificateChainWithHttpInfo(string collectionId, string? gatewayId = default(string?), string? deviceId = default(string?), int operationIndex = 0)
        {
            // verify the required parameter 'collectionId' is set
            if (collectionId == null)
            {
                throw new Com.Lab5e.Span.Client.ApiException(400, "Missing required parameter 'collectionId' when calling CertificatesApi->RetrieveCertificateChain");
            }

            Com.Lab5e.Span.Client.RequestOptions localVarRequestOptions = new Com.Lab5e.Span.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Com.Lab5e.Span.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Com.Lab5e.Span.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("collectionId", Com.Lab5e.Span.Client.ClientUtils.ParameterToString(collectionId)); // path parameter
            if (gatewayId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Com.Lab5e.Span.Client.ClientUtils.ParameterToMultiMap("", "gatewayId", gatewayId));
            }
            if (deviceId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Com.Lab5e.Span.Client.ClientUtils.ParameterToMultiMap("", "deviceId", deviceId));
            }

            localVarRequestOptions.Operation = "CertificatesApi.RetrieveCertificateChain";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (APIToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-Token", this.Configuration.GetApiKeyWithPrefix("X-API-Token"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<CertificateChainResponse>("/span/collections/{collectionId}/certificates", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RetrieveCertificateChain", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get certificate chain Get the certificate chain for the root CA and intermediate certificates used by the device, gateway and server certificates. It is highly recommended to verify the server certificate when sending data to avoid any man-in-the-middle attacks. This chain will contain all required certificates needed to verify the client certificate.
        /// </summary>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="deviceId"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CertificateChainResponse</returns>
        public async System.Threading.Tasks.Task<CertificateChainResponse> RetrieveCertificateChainAsync(string collectionId, string? gatewayId = default(string?), string? deviceId = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Com.Lab5e.Span.Client.ApiResponse<CertificateChainResponse> localVarResponse = await RetrieveCertificateChainWithHttpInfoAsync(collectionId, gatewayId, deviceId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get certificate chain Get the certificate chain for the root CA and intermediate certificates used by the device, gateway and server certificates. It is highly recommended to verify the server certificate when sending data to avoid any man-in-the-middle attacks. This chain will contain all required certificates needed to verify the client certificate.
        /// </summary>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="gatewayId"> (optional)</param>
        /// <param name="deviceId"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CertificateChainResponse)</returns>
        public async System.Threading.Tasks.Task<Com.Lab5e.Span.Client.ApiResponse<CertificateChainResponse>> RetrieveCertificateChainWithHttpInfoAsync(string collectionId, string? gatewayId = default(string?), string? deviceId = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'collectionId' is set
            if (collectionId == null)
            {
                throw new Com.Lab5e.Span.Client.ApiException(400, "Missing required parameter 'collectionId' when calling CertificatesApi->RetrieveCertificateChain");
            }


            Com.Lab5e.Span.Client.RequestOptions localVarRequestOptions = new Com.Lab5e.Span.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Com.Lab5e.Span.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Com.Lab5e.Span.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("collectionId", Com.Lab5e.Span.Client.ClientUtils.ParameterToString(collectionId)); // path parameter
            if (gatewayId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Com.Lab5e.Span.Client.ClientUtils.ParameterToMultiMap("", "gatewayId", gatewayId));
            }
            if (deviceId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Com.Lab5e.Span.Client.ClientUtils.ParameterToMultiMap("", "deviceId", deviceId));
            }

            localVarRequestOptions.Operation = "CertificatesApi.RetrieveCertificateChain";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (APIToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-Token", this.Configuration.GetApiKeyWithPrefix("X-API-Token"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<CertificateChainResponse>("/span/collections/{collectionId}/certificates", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RetrieveCertificateChain", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Sign certificate Sign a device or gateway (aka client) certificate. The certificate is a X509 Certificate signing request PEM encoded. The certificate will be valid for 14 days and must be renewed.
        /// </summary>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SignCertificateResponse</returns>
        public SignCertificateResponse SignCertificate(string collectionId, SignCertificateBody body, int operationIndex = 0)
        {
            Com.Lab5e.Span.Client.ApiResponse<SignCertificateResponse> localVarResponse = SignCertificateWithHttpInfo(collectionId, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Sign certificate Sign a device or gateway (aka client) certificate. The certificate is a X509 Certificate signing request PEM encoded. The certificate will be valid for 14 days and must be renewed.
        /// </summary>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SignCertificateResponse</returns>
        public Com.Lab5e.Span.Client.ApiResponse<SignCertificateResponse> SignCertificateWithHttpInfo(string collectionId, SignCertificateBody body, int operationIndex = 0)
        {
            // verify the required parameter 'collectionId' is set
            if (collectionId == null)
            {
                throw new Com.Lab5e.Span.Client.ApiException(400, "Missing required parameter 'collectionId' when calling CertificatesApi->SignCertificate");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Com.Lab5e.Span.Client.ApiException(400, "Missing required parameter 'body' when calling CertificatesApi->SignCertificate");
            }

            Com.Lab5e.Span.Client.RequestOptions localVarRequestOptions = new Com.Lab5e.Span.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Com.Lab5e.Span.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Com.Lab5e.Span.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("collectionId", Com.Lab5e.Span.Client.ClientUtils.ParameterToString(collectionId)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "CertificatesApi.SignCertificate";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (APIToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-Token", this.Configuration.GetApiKeyWithPrefix("X-API-Token"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SignCertificateResponse>("/span/collections/{collectionId}/certificates/sign", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignCertificate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Sign certificate Sign a device or gateway (aka client) certificate. The certificate is a X509 Certificate signing request PEM encoded. The certificate will be valid for 14 days and must be renewed.
        /// </summary>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignCertificateResponse</returns>
        public async System.Threading.Tasks.Task<SignCertificateResponse> SignCertificateAsync(string collectionId, SignCertificateBody body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Com.Lab5e.Span.Client.ApiResponse<SignCertificateResponse> localVarResponse = await SignCertificateWithHttpInfoAsync(collectionId, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Sign certificate Sign a device or gateway (aka client) certificate. The certificate is a X509 Certificate signing request PEM encoded. The certificate will be valid for 14 days and must be renewed.
        /// </summary>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignCertificateResponse)</returns>
        public async System.Threading.Tasks.Task<Com.Lab5e.Span.Client.ApiResponse<SignCertificateResponse>> SignCertificateWithHttpInfoAsync(string collectionId, SignCertificateBody body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'collectionId' is set
            if (collectionId == null)
            {
                throw new Com.Lab5e.Span.Client.ApiException(400, "Missing required parameter 'collectionId' when calling CertificatesApi->SignCertificate");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Com.Lab5e.Span.Client.ApiException(400, "Missing required parameter 'body' when calling CertificatesApi->SignCertificate");
            }


            Com.Lab5e.Span.Client.RequestOptions localVarRequestOptions = new Com.Lab5e.Span.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Com.Lab5e.Span.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Com.Lab5e.Span.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("collectionId", Com.Lab5e.Span.Client.ClientUtils.ParameterToString(collectionId)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "CertificatesApi.SignCertificate";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (APIToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-Token", this.Configuration.GetApiKeyWithPrefix("X-API-Token"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<SignCertificateResponse>("/span/collections/{collectionId}/certificates/sign", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SignCertificate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Verify certificate Verify client certificate. If a client certificate fails it can be tricky to pinpoint exactly *why* the certificate isn&#39;t accepted. This resource validates the client certificate and returns the error in plain text.
        /// </summary>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>VerifyCertificateResponse</returns>
        public VerifyCertificateResponse VerifyCertificate(string collectionId, VerifyCertificateBody body, int operationIndex = 0)
        {
            Com.Lab5e.Span.Client.ApiResponse<VerifyCertificateResponse> localVarResponse = VerifyCertificateWithHttpInfo(collectionId, body);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Verify certificate Verify client certificate. If a client certificate fails it can be tricky to pinpoint exactly *why* the certificate isn&#39;t accepted. This resource validates the client certificate and returns the error in plain text.
        /// </summary>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of VerifyCertificateResponse</returns>
        public Com.Lab5e.Span.Client.ApiResponse<VerifyCertificateResponse> VerifyCertificateWithHttpInfo(string collectionId, VerifyCertificateBody body, int operationIndex = 0)
        {
            // verify the required parameter 'collectionId' is set
            if (collectionId == null)
            {
                throw new Com.Lab5e.Span.Client.ApiException(400, "Missing required parameter 'collectionId' when calling CertificatesApi->VerifyCertificate");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Com.Lab5e.Span.Client.ApiException(400, "Missing required parameter 'body' when calling CertificatesApi->VerifyCertificate");
            }

            Com.Lab5e.Span.Client.RequestOptions localVarRequestOptions = new Com.Lab5e.Span.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Com.Lab5e.Span.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Com.Lab5e.Span.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("collectionId", Com.Lab5e.Span.Client.ClientUtils.ParameterToString(collectionId)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "CertificatesApi.VerifyCertificate";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (APIToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-Token", this.Configuration.GetApiKeyWithPrefix("X-API-Token"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<VerifyCertificateResponse>("/span/collections/{collectionId}/certificates/verify", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("VerifyCertificate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Verify certificate Verify client certificate. If a client certificate fails it can be tricky to pinpoint exactly *why* the certificate isn&#39;t accepted. This resource validates the client certificate and returns the error in plain text.
        /// </summary>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VerifyCertificateResponse</returns>
        public async System.Threading.Tasks.Task<VerifyCertificateResponse> VerifyCertificateAsync(string collectionId, VerifyCertificateBody body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Com.Lab5e.Span.Client.ApiResponse<VerifyCertificateResponse> localVarResponse = await VerifyCertificateWithHttpInfoAsync(collectionId, body, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Verify certificate Verify client certificate. If a client certificate fails it can be tricky to pinpoint exactly *why* the certificate isn&#39;t accepted. This resource validates the client certificate and returns the error in plain text.
        /// </summary>
        /// <exception cref="Com.Lab5e.Span.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionId"></param>
        /// <param name="body"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (VerifyCertificateResponse)</returns>
        public async System.Threading.Tasks.Task<Com.Lab5e.Span.Client.ApiResponse<VerifyCertificateResponse>> VerifyCertificateWithHttpInfoAsync(string collectionId, VerifyCertificateBody body, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'collectionId' is set
            if (collectionId == null)
            {
                throw new Com.Lab5e.Span.Client.ApiException(400, "Missing required parameter 'collectionId' when calling CertificatesApi->VerifyCertificate");
            }

            // verify the required parameter 'body' is set
            if (body == null)
            {
                throw new Com.Lab5e.Span.Client.ApiException(400, "Missing required parameter 'body' when calling CertificatesApi->VerifyCertificate");
            }


            Com.Lab5e.Span.Client.RequestOptions localVarRequestOptions = new Com.Lab5e.Span.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Com.Lab5e.Span.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Com.Lab5e.Span.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("collectionId", Com.Lab5e.Span.Client.ClientUtils.ParameterToString(collectionId)); // path parameter
            localVarRequestOptions.Data = body;

            localVarRequestOptions.Operation = "CertificatesApi.VerifyCertificate";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (APIToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-API-Token", this.Configuration.GetApiKeyWithPrefix("X-API-Token"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<VerifyCertificateResponse>("/span/collections/{collectionId}/certificates/verify", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("VerifyCertificate", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
